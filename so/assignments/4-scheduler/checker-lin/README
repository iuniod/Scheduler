Nume: Olteanu Eduard-Florin
Grupa: 336CAb

Tema 4 SO - Scheduler


Organizare
In so_scheduler.c este implementata tema propriu-zisa. In utils.h avem definit
macro-ul DIE, iar in pqueue.h este implementata o coada de prioritati sub
forma unei liste inlantuite care are in pq->head elementul cu cea mai mare
prioritate.

Pentru salvarea informatiilor necesare am folosit structura Scheduler pentru a
retine tot ce tine de scheduler: numarul maxim de evenimente care pot 
aparea, marimea cunatei de timp, numarul maxim de thread-uri, thread-ul care
ruleaza in momentul curent, lista cu pointeri catre elemente de tip Thread,
coada de prioritati si un semafor care ne ajuta atunci cand trebuie sa asteptam
thread-urile inainte sa le distrugem care se deblocheaza atunci cand thread-ul
curent a terminat de executat si se deblocheaza atunci cand trebuie asteptate
sa se initializeze thread-uri.

Iar pentru un thread am salvat in structura Thread prioritatea acestuia, timpul
pe care il mai are din cuanta, event-ul io, id-ul, statusul curent, functia pe
care trebuie sa o execute si un semafor care il opreste din executie cand este 
nevoie si il elibereaza cand ii vine randul.

De asemenea am definit intr-un enum cele 5 stari in care se poate afla un thread.

In so_init se aloca memorie pentru scheduler. In so_fork se creeaza thread-urile,
iar atunci cand un thread este creat este aduagat imediat in lista thread-urilor
dar si in coada de prioritati. Daca nu este niciun thread care ruleaza se
reface programul de rulare al thread-urilor, altfel se executa so_exec.

So_exec scade o unitate din cuanta thread-ului curent si apoi reface scheduler,
totodata blocheaza thread-ul curent din executare pentru a astepta confirmarea
urmatorului thread care trebuie sa execute.

So_wait trece thread-ul care ruleaza in momentul curent in startea WAITING si
apeleaza so_exec, iar so_signal verifica ce thread-uri asteapta evenimentul
primit ca paramentru si le trece in starea READY, adaugandu-le inapoi in coada
si apeland si so_exec.

In so_end se asteapta sa termine thread-ul pe care ruleaza semaforul si apoi se
da join la toate thread-urile. Apoi se elibereaza toata memoria, distrugandu-se
si semafoarele.

thread_function este functia daca ca parametru la crearea unui thread. Primeste
ca argument structura Thread corespunzatoare thread-ului. Mai intai asteapta
la semafor pentru a executa handler-ul, iar apoi se trece in starea TERMINATED
si apeleaza iar rescheduler-ul pentru a notifica ca a terminat de executat.

In reschedule se verifica mai intai daca mai sunt thread-uri in coada, iar daca
nu mai sunt se verifica daca a terminat si thread-ul curent si se semnalizeaza
semaforul scheduler-ului ca toate thread-urile au terminat. Daca thread-ul
curent nu a terminat (dar este ultuimul din coada) este semnalat si el pentru
a executa. Daca mai sunt si alte elemente in coada se extrage elementul cu cea
mai mare prioritate din coada. 
Daca nu este niciun thread care executa sau ultimul thread care a executate a
terminat sau asteapta se pune thread-ul luat din coada si se apeleaza
run_thread.
In run_thread se scoate efectiv elementul
din coada, se trece in starea RUNNING, se initializeaza timpul pe care il
are disponibil si se elibereaza semaforul lui pentru a incepe sa execute.
Daca prioritatea thread-ului luat din coada este mai mare decat a celui care
ruleaza in momentul curent se pune in coada cel curent si incepe sa execute 
cel cu prioritate mai mare.
Altfel (daca prioritatea thread-ului curent este >= decat a primului din coada)
daca thread-ul curent a terminat timpul pe care il avea disponibil dar
prioritatea lui este mai mare se reinitializeaza cuanta de timp. Dar daca
prioritatea lui este aceaasi cu a primului proces din coada (round robin) se
pune la rulat celelalt thread si se pune inapoi in coada thread-ul care rula
inainte.


Consider ca tema este utila dpdv al intelegerii unui scheduler de procese.


Consider implementarea destul de eficienta, la nivelul identificarii thread-ului
cu cea mai mare prioritate se mai putea eficientiza deoarece eu salvez in coada
doar id-ul si prioritatea thread-ului iar apoi trebuie sa parcurg prin toate 
thread-urile din vector pentru a gasi structura thread-ului care ma intereseaza.


Implementare
Intregul enunt al temei a fost implementat.
Am intampinat anumite dificultati in identificarea unor probleme ce tineau de
id-ul thread-ului asignat deoarece eu salvam unsigned int iar acesta putea fi
mai mare si dadea segfault, dar daca rulam cu valgrind valorile pe care le putea
primi erau mai mici si nu mai vedeam segfault-ul pentru a il inspecta cu valgrind.


Makefile
Se compileaza cu make. Nu se ruleaza.

Bibliografie
https://ocw.cs.pub.ro/courses/so/laboratoare/laborator-08
https://ocw.cs.pub.ro/courses/so/laboratoare/laborator-09
